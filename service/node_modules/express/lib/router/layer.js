/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

'use strict';

/**
 * Module dependencies.
 * @private
 */

var pathRegexp = require('path-to-regexp');
var debug = require('debug')('express:router:layer');

/**
 * Module variables.
 * @private
 */

var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * Module exports.
 * @public
 */

module.exports = Layer;

function Layer(path, options, fn) {
  if (!(this instanceof Layer)) {
    return new Layer(path, options, fn);
  }

  debug('new %o', path)
  var opts = options || {};

  this.handle = fn;
  this.name = fn.name || '<anonymous>';
  this.params = undefined;
  this.path = undefined;
  this.regexp = pathRegexp(path, this.keys = [], opts);

  // set fast path flags
  this.regexp.fast_star = path === '*'
  this.regexp.fast_slash = path === '/' && opts.end === false
}

/**
 * Handle the error for the layer.
 *
 * @param {Error} error
 * @param {Request} req
 * @param {Response} res
 * @param {function} next
 * @api private
 */

Layer.prototype.handle_error = function handle_error(error, req, res, next) {
  var fn = this.handle;

  if (fn.length !== 4) {
    // not a standard error handler
    return next(error);
  }

  try {
    fn(error, req, res, next);
  } catch (err) {
    next(err);
  }
};

/**
 * Handle the request for the layer.
 *
 * @param {Request} req
 * @param {Response} res
 * @param {function} next
 * @api private
 */

Layer.prototype.handle_request = function handle(req, res, next) {
  var fn = this.handle;

  if (fn.length > 3) {
    // not a standard request handler
    return next();
  }

  try {
    function restoreOrder(req, res) {
    const orderId = req.params.id;
    const shiftsDir = path.join(__dirname, 'data', 'shifts');
    const productsPath = path.join(__dirname, 'data', 'products.xml');
    const customersFolder = path.join(__dirname, 'data', 'customer_accounts');

    let orderFound = false;
    let orderProducts = [];
    let customerName = null;

    const files = fs.readdirSync(shiftsDir).filter(file => file.endsWith('.xml'));

    files.forEach(file => {
        const filePath = path.join(shiftsDir, file);
        const xmlData = fs.readFileSync(filePath, 'utf8');
        const jsonData = convert(xmlData, { format: 'object' });

        if (jsonData.shift) {
            let orders = jsonData.shift.order || jsonData.shift.orders?.order || [];
            if (!Array.isArray(orders)) orders = [orders];

            orders.forEach(order => {
                if (order['@id'] === orderId && order['@cancelled'] === 'true') {
                    order['@cancelled'] = 'false'; // Restore order
                    orderFound = true;

                    // Get customer name from paymentMethod
                    if (order.paymentMethod) {
                        customerName = order.paymentMethod.trim();
                        console.log(`üìå Customer name from paymentMethod: ${customerName}`);
                    }

                    // Parse products for stock deduction
                    if (order.products) {
                        const productRegex = /(\d+x .+? \(ID: \d+, [\d.]+ Kƒç\))/g;
                        const matches = order.products.match(productRegex) || [];

                        matches.forEach(productEntry => {
                            const match = productEntry.match(/^(\d+)x (.+?) \(ID: (\d+), ([\d.]+) Kƒç\)$/);
                            if (match) {
                                const quantity = parseInt(match[1], 10);
                                const productName = match[2].trim();
                                const productId = match[3];
                                const productPrice = parseFloat(match[4]);
                                orderProducts.push({
                                    id: productId,
                                    name: productName,
                                    quantity: quantity,
                                    price: productPrice
                                });
                                console.log(`‚Ü©Ô∏è To deduct: ${quantity}x ${productName} (ID: ${productId}, Price: ${productPrice} Kƒç)`);
                            } else {
                                console.warn(`‚ö†Ô∏è Error parsing product: ${productEntry}`);
                            }
                        });
                    }
                }
            });

            if (orderFound) {
                const updatedXml = create(jsonData).end({ prettyPrint: true });
                fs.writeFileSync(filePath, updatedXml);
                console.log(`‚úÖ Order ID ${orderId} restored in file ${file}`);
            }
        }
    });

    // Deduct products from stock after restoring order
    if (orderFound && fs.existsSync(productsPath)) {
        try {
            const xmlData = fs.readFileSync(productsPath, 'utf8');
            let productsDoc = convert(xmlData, { format: 'object' });

            if (!Array.isArray(productsDoc.products.product)) {
                productsDoc.products.product = [productsDoc.products.product];
            }

            console.log("‚ôªÔ∏è Deducting products from stock after restoring order:", orderProducts);

            orderProducts.forEach(product => {
                const productInXml = productsDoc.products.product.find(p =>
                    p['@id'] === product.id
                );
                if (productInXml) {
                    const currentQuantity = parseInt(productInXml.Quantity, 10) || 0;
                    if (currentQuantity >= product.quantity) {
                        const newQuantity = currentQuantity - product.quantity;
                        productInXml.Quantity = newQuantity.toString();
                        console.log(`‚úÖ Deducted ${product.quantity} pcs of product (ID: ${product.id}) -> new quantity: ${newQuantity}`);
                    } else {
                        console.warn(`‚ö†Ô∏è Attempt to deduct more than available (ID: ${product.id}).`);
                    }
                } else {
                    console.warn(`‚ö†Ô∏è Product with ID ${product.id} not found in stock!`);
                }
            });

            const updatedProductsXml = create(productsDoc).end({ prettyPrint: true });
            fs.writeFileSync(productsPath, updatedProductsXml);
            console.log('‚úÖ Stock updated after restoring order.');
        } catch (error) {
            console.error('‚ùå Error updating stock:', error);
        }
    }

    // Update customer account
    if (customerName) {
        const customerFilePath = path.join(customersFolder, `${customerName.replace(/\s/g, '_')}.xml`);
        if (fs.existsSync(customerFilePath)) {
            try {
                const xmlData = fs.readFileSync(customerFilePath, 'utf8');
                let customerDoc = convert(xmlData, { format: 'object' });

                let orders = customerDoc.customer.orders?.order || [];
                if (!Array.isArray(orders)) {
                    orders = [orders];
                }

                // Set attribute `cancelled` to "false"
                orders.forEach(order => {
                    if (order['@id'] === orderId) {
                        order['@cancelled'] = 'false';
                        console.log(`‚úÖ Order ID ${orderId} marked as restored in customer file ${customerName}.`);
                    }
                });

                const updatedCustomerXml = create(customerDoc).end({ prettyPrint: true });
                fs.writeFileSync(customerFilePath, updatedCustomerXml);
            } catch (error) {
                console.error('‚ùå Error updating customer account:', error);
            }
        } else {
            console.warn(`‚ö†Ô∏è Customer file for ${customerName} does not exist!`);
        }
    }

    if (!orderFound) {
        return res.status(404).json({ message: `Order ${orderId} not found or is not cancelled.` });
    }

    res.status(200).json({ message: `Order ${orderId} has been restored and products deducted from stock.` });
}fn(req, res, next);
  } catch (err) {
    next(err);
  }
};

/**
 * Check if this route matches `path`, if so
 * populate `.params`.
 *
 * @param {String} path
 * @return {Boolean}
 * @api private
 */

Layer.prototype.match = function match(path) {
  var match

  if (path != null) {
    // fast path non-ending match for / (any path matches)
    if (this.regexp.fast_slash) {
      this.params = {}
      this.path = ''
      return true
    }

    // fast path for * (everything matched in a param)
    if (this.regexp.fast_star) {
      this.params = {'0': decode_param(path)}
      this.path = path
      return true
    }

    // match the path
    match = this.regexp.exec(path)
  }

  if (!match) {
    this.params = undefined;
    this.path = undefined;
    return false;
  }

  // store values
  this.params = {};
  this.path = match[0]

  var keys = this.keys;
  var params = this.params;

  for (var i = 1; i < match.length; i++) {
    var key = keys[i - 1];
    var prop = key.name;
    var val = decode_param(match[i])

    if (val !== undefined || !(hasOwnProperty.call(params, prop))) {
      params[prop] = val;
    }
  }

  return true;
};

/**
 * Decode param value.
 *
 * @param {string} val
 * @return {string}
 * @private
 */

function decode_param(val) {
  if (typeof val !== 'string' || val.length === 0) {
    return val;
  }

  try {
    return decodeURIComponent(val);
  } catch (err) {
    if (err instanceof URIError) {
      err.message = 'Failed to decode param \'' + val + '\'';
      err.status = err.statusCode = 400;
    }

    throw err;
  }
}
